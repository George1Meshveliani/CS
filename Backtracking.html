<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backtracking Pattern - LeetCode Patterns</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        html { scroll-behavior: smooth; }
        body { font-family: 'Inter', sans-serif; }
        .prose { max-width: 80ch; }
        .prose h1 { font-size: 2.5rem; font-weight: 700; margin-bottom: 1rem; }
        .prose h2, .section-title { font-size: 2.25rem; font-weight: 700; margin-top: 3rem; margin-bottom: 1.5rem; border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; }
        .prose h3 { font-size: 1.5rem; font-weight: 600; margin-top: 2rem; margin-bottom: 0.75rem; }
        .prose p, .prose li { font-size: 1.125rem; line-height: 1.75; }
        .prose pre { background-color: #1f2937; color: #d1d5db; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; }
        .prose code { font-family: 'Courier New', Courier, monospace; background-color: #e5e7eb; padding: 0.2rem 0.4rem; border-radius: 0.25rem; font-size: 0.95em; }
        .prose pre code { background-color: transparent; padding: 0; color: inherit; }
        .problem-card { background-color: white; border-radius: 0.5rem; padding: 1.5rem; margin-bottom: 1.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1); }
        .solution-content { display: none; margin-top: 1rem; padding-top: 1rem; border-top: 2px solid #e5e7eb; }
        .solution-content.show { display: block; }
        .toggle-btn { background-color: #3b82f6; color: white; padding: 0.5rem 1rem; border-radius: 0.375rem; border: none; cursor: pointer; font-weight: 600; }
        .toggle-btn:hover { background-color: #2563eb; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <header class="bg-white shadow-md sticky top-0 z-10">
        <nav class="container mx-auto px-6 py-4">
            <h1 class="text-2xl font-bold text-gray-900">Backtracking Pattern</h1>
        </nav>
    </header>

    <main class="container mx-auto px-6 py-12">
        <section id="pattern" class="mb-12">
            <article class="prose lg:prose-xl max-w-7xl bg-white p-8 rounded-lg shadow-lg">
                <h1>Backtracking Pattern</h1>
                <p><strong>Backtracking</strong> is an algorithmic technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point in time.</p>

                <h2>When to Use This Pattern</h2>
                <ul>
                    <li>Finding all possible solutions (combinations, permutations, subsets)</li>
                    <li>Constraint satisfaction problems (N-Queens, Sudoku)</li>
                    <li>Problems where you need to explore all possibilities</li>
                    <li>When you need to undo choices and try alternatives</li>
                    <li>Combinatorial problems</li>
                </ul>

                <h2>Key Concepts</h2>
                <p>Backtracking follows these steps:</p>
                <ol>
                    <li><strong>Choose:</strong> Make a choice</li>
                    <li><strong>Explore:</strong> Recursively solve the problem with the choice</li>
                    <li><strong>Unchoose:</strong> Undo the choice (backtrack) and try the next option</li>
                </ol>

                <h3>Visual Representation - Permutation Tree</h3>
                <div style="background: linear-gradient(135deg, #f3e8ff 0%, #e9d5ff 100%); border: 2px solid #a855f7; border-radius: 1rem; padding: 2.5rem; margin: 2rem 0; box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);">
                    <h4 style="margin-bottom: 2rem; color: #7e22ce; font-weight: 700; font-size: 1.5rem; text-align: center;">Backtracking - Generating Permutations of [1, 2, 3]</h4>
                    <svg width="100%" height="550" viewBox="0 0 1000 550" style="max-width: 1000px; margin: 0 auto; background: white; border-radius: 0.75rem; padding: 1.5rem;">
                        <defs>
                            <linearGradient id="rootGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:#6366f1;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#4f46e5;stop-opacity:1" />
                            </linearGradient>
                            <linearGradient id="chooseGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:#10b981;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#059669;stop-opacity:1" />
                            </linearGradient>
                            <linearGradient id="exploreGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:#fbbf24;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#f59e0b;stop-opacity:1" />
                            </linearGradient>
                            <linearGradient id="solutionGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:#ef4444;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#dc2626;stop-opacity:1" />
                            </linearGradient>
                            <filter id="treeGlow">
                                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                                <feMerge>
                                    <feMergeNode in="coloredBlur"/>
                                    <feMergeNode in="SourceGraphic"/>
                                </feMerge>
                            </filter>
                            <filter id="shadow7">
                                <feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.25"/>
                            </filter>
                        </defs>
                        
                        <!-- Title -->
                        <text x="500" y="35" text-anchor="middle" font-size="18" font-weight="700" fill="#1e293b">Backtracking Tree: Generating All Permutations</text>
                        
                        <!-- Root -->
                        <ellipse cx="500" cy="70" rx="60" ry="30" fill="url(#rootGradient)" stroke="#4f46e5" stroke-width="3" filter="url(#shadow7)"/>
                        <text x="500" y="78" text-anchor="middle" font-size="16" font-weight="700" fill="white">[]</text>
                        <text x="500" y="110" text-anchor="middle" font-size="13" font-weight="600" fill="#4f46e5">Start</text>
                        
                        <!-- Level 1 - Choose -->
                        <path d="M 480 100 L 200 150" stroke="#6b7280" stroke-width="2.5" marker-end="url(#treeArrow)"/>
                        <ellipse cx="200" cy="180" rx="50" ry="25" fill="url(#chooseGradient)" stroke="#059669" stroke-width="2.5" filter="url(#shadow7)"/>
                        <text x="200" y="188" text-anchor="middle" font-size="14" font-weight="700" fill="white">[1]</text>
                        
                        <path d="M 500 100 L 500 150" stroke="#6b7280" stroke-width="2.5" marker-end="url(#treeArrow)"/>
                        <ellipse cx="500" cy="180" rx="50" ry="25" fill="url(#chooseGradient)" stroke="#059669" stroke-width="2.5" filter="url(#shadow7)"/>
                        <text x="500" y="188" text-anchor="middle" font-size="14" font-weight="700" fill="white">[2]</text>
                        
                        <path d="M 520 100 L 800 150" stroke="#6b7280" stroke-width="2.5" marker-end="url(#treeArrow)"/>
                        <ellipse cx="800" cy="180" rx="50" ry="25" fill="url(#chooseGradient)" stroke="#059669" stroke-width="2.5" filter="url(#shadow7)"/>
                        <text x="800" y="188" text-anchor="middle" font-size="14" font-weight="700" fill="white">[3]</text>
                        
                        <defs>
                            <marker id="treeArrow" markerWidth="10" markerHeight="10" refX="5" refY="3" orient="auto">
                                <polygon points="0 0, 10 3, 0 6" fill="#6b7280"/>
                            </marker>
                        </defs>
                        
                        <!-- Level 2 - Explore -->
                        <path d="M 190 205 L 100 250" stroke="#6b7280" stroke-width="2.5" marker-end="url(#treeArrow)"/>
                        <ellipse cx="100" cy="280" rx="55" ry="28" fill="url(#exploreGradient)" stroke="#f59e0b" stroke-width="2.5" filter="url(#shadow7)"/>
                        <text x="100" y="288" text-anchor="middle" font-size="13" font-weight="700" fill="white">[1,2]</text>
                        
                        <path d="M 200 205 L 200 250" stroke="#6b7280" stroke-width="2.5" marker-end="url(#treeArrow)"/>
                        <ellipse cx="200" cy="280" rx="55" ry="28" fill="url(#exploreGradient)" stroke="#f59e0b" stroke-width="2.5" filter="url(#shadow7)"/>
                        <text x="200" y="288" text-anchor="middle" font-size="13" font-weight="700" fill="white">[1,3]</text>
                        
                        <path d="M 490 205 L 400 250" stroke="#6b7280" stroke-width="2.5" marker-end="url(#treeArrow)"/>
                        <ellipse cx="400" cy="280" rx="55" ry="28" fill="url(#exploreGradient)" stroke="#f59e0b" stroke-width="2.5" filter="url(#shadow7)"/>
                        <text x="400" y="288" text-anchor="middle" font-size="13" font-weight="700" fill="white">[2,1]</text>
                        
                        <path d="M 500 205 L 500 250" stroke="#6b7280" stroke-width="2.5" marker-end="url(#treeArrow)"/>
                        <ellipse cx="500" cy="280" rx="55" ry="28" fill="url(#exploreGradient)" stroke="#f59e0b" stroke-width="2.5" filter="url(#shadow7)"/>
                        <text x="500" y="288" text-anchor="middle" font-size="13" font-weight="700" fill="white">[2,3]</text>
                        
                        <path d="M 790 205 L 700 250" stroke="#6b7280" stroke-width="2.5" marker-end="url(#treeArrow)"/>
                        <ellipse cx="700" cy="280" rx="55" ry="28" fill="url(#exploreGradient)" stroke="#f59e0b" stroke-width="2.5" filter="url(#shadow7)"/>
                        <text x="700" y="288" text-anchor="middle" font-size="13" font-weight="700" fill="white">[3,1]</text>
                        
                        <path d="M 800 205 L 800 250" stroke="#6b7280" stroke-width="2.5" marker-end="url(#treeArrow)"/>
                        <ellipse cx="800" cy="280" rx="55" ry="28" fill="url(#exploreGradient)" stroke="#f59e0b" stroke-width="2.5" filter="url(#shadow7)"/>
                        <text x="800" y="288" text-anchor="middle" font-size="13" font-weight="700" fill="white">[3,2]</text>
                        
                        <!-- Level 3 - Solutions -->
                        <path d="M 100 308 L 50 350" stroke="#ef4444" stroke-width="3" marker-end="url(#treeArrow)"/>
                        <rect x="20" y="360" width="70" height="35" fill="url(#solutionGradient)" stroke="#dc2626" stroke-width="3" rx="6" filter="url(#treeGlow)"/>
                        <text x="55" y="382" text-anchor="middle" font-size="13" font-weight="700" fill="white">[1,2,3]</text>
                        
                        <path d="M 200 308 L 200 350" stroke="#ef4444" stroke-width="3" marker-end="url(#treeArrow)"/>
                        <rect x="170" y="360" width="70" height="35" fill="url(#solutionGradient)" stroke="#dc2626" stroke-width="3" rx="6" filter="url(#treeGlow)"/>
                        <text x="205" y="382" text-anchor="middle" font-size="13" font-weight="700" fill="white">[1,3,2]</text>
                        
                        <path d="M 400 308 L 400 350" stroke="#ef4444" stroke-width="3" marker-end="url(#treeArrow)"/>
                        <rect x="370" y="360" width="70" height="35" fill="url(#solutionGradient)" stroke="#dc2626" stroke-width="3" rx="6" filter="url(#treeGlow)"/>
                        <text x="405" y="382" text-anchor="middle" font-size="13" font-weight="700" fill="white">[2,1,3]</text>
                        
                        <path d="M 500 308 L 500 350" stroke="#ef4444" stroke-width="3" marker-end="url(#treeArrow)"/>
                        <rect x="470" y="360" width="70" height="35" fill="url(#solutionGradient)" stroke="#dc2626" stroke-width="3" rx="6" filter="url(#treeGlow)"/>
                        <text x="505" y="382" text-anchor="middle" font-size="13" font-weight="700" fill="white">[2,3,1]</text>
                        
                        <path d="M 700 308 L 700 350" stroke="#ef4444" stroke-width="3" marker-end="url(#treeArrow)"/>
                        <rect x="670" y="360" width="70" height="35" fill="url(#solutionGradient)" stroke="#dc2626" stroke-width="3" rx="6" filter="url(#treeGlow)"/>
                        <text x="705" y="382" text-anchor="middle" font-size="13" font-weight="700" fill="white">[3,1,2]</text>
                        
                        <path d="M 800 308 L 800 350" stroke="#ef4444" stroke-width="3" marker-end="url(#treeArrow)"/>
                        <rect x="770" y="360" width="70" height="35" fill="url(#solutionGradient)" stroke="#dc2626" stroke-width="3" rx="6" filter="url(#treeGlow)"/>
                        <text x="805" y="382" text-anchor="middle" font-size="13" font-weight="700" fill="white">[3,2,1]</text>
                        
                        <!-- Backtracking explanation box -->
                        <rect x="50" y="420" width="900" height="100" fill="#f8fafc" stroke="#e2e8f0" stroke-width="2.5" rx="10" filter="url(#shadow7)"/>
                        <text x="500" y="450" text-anchor="middle" font-size="16" font-weight="700" fill="#1e293b">Backtracking Process Flow</text>
                        
                        <g transform="translate(150, 470)">
                            <rect x="0" y="0" width="25" height="20" fill="url(#rootGradient)" rx="4"/>
                            <text x="35" y="15" font-size="13" font-weight="600" fill="#1e293b">Start: Empty path []</text>
                            
                            <rect x="0" y="30" width="25" height="20" fill="url(#chooseGradient)" rx="4"/>
                            <text x="35" y="45" font-size="13" font-weight="600" fill="#1e293b">Choose: Add element to path</text>
                            
                            <rect x="0" y="60" width="25" height="20" fill="url(#exploreGradient)" rx="4"/>
                            <text x="35" y="75" font-size="13" font-weight="600" fill="#1e293b">Explore: Recursively build solution</text>
                        </g>
                        
                        <g transform="translate(550, 470)">
                            <rect x="0" y="0" width="25" height="20" fill="url(#solutionGradient)" rx="4"/>
                            <text x="35" y="15" font-size="13" font-weight="600" fill="#1e293b">Solution: Complete path found</text>
                            
                            <text x="0" y="45" font-size="12" fill="#6b7280">If path invalid or complete:</text>
                            <text x="0" y="65" font-size="12" font-weight="700" fill="#ef4444">← Backtrack (unchoose) and try next option</text>
                        </g>
                    </svg>
                    
                    <div style="margin-top: 2rem; padding: 1.25rem; background: linear-gradient(135deg, #f3e8ff 0%, #e9d5ff 100%); border-left: 5px solid #a855f7; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
                        <p style="margin: 0; font-size: 1rem; color: #6b21a8; font-weight: 600;"><strong>Backtracking Principle:</strong> Systematically explore all possibilities by making choices, exploring recursively, and undoing (backtracking) when a path doesn't lead to a solution. This ensures we find all valid solutions without missing any.</p>
                    </div>
                </div>

                <h3>Template</h3>
                <pre><code>def backtrack(current_state, choices):
    # Base case: solution found
    if is_solution(current_state):
        add_to_results(current_state)
        return
    
    # Try each choice
    for choice in choices:
        # Make choice
        current_state.append(choice)
        
        # Check if valid (pruning)
        if is_valid(current_state):
            # Explore
            backtrack(current_state, remaining_choices)
        
        # Unchoose (backtrack)
        current_state.pop()</code></pre>
            </article>
        </section>

        <section id="algorithm" class="mb-12">
            <article class="prose lg:prose-xl max-w-7xl bg-white p-8 rounded-lg shadow-lg">
                <h1>Algorithm Section</h1>
                
                <h2>General Backtracking Algorithm</h2>
                <pre><code>function backtrack(path, choices):
    if isComplete(path):
        addToResults(path)
        return
    
    for each choice in choices:
        if isValid(path, choice):
            path.add(choice)
            backtrack(path, getRemainingChoices(choices, choice))
            path.remove(choice)  // Backtrack</code></pre>

                <h2>Implementation in C++</h2>
                <pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

void generate_permutations(vector&lt;int&gt;& nums, vector&lt;int&gt;& path, 
                          vector&lt;bool&gt;& used, vector&lt;vector&lt;int&gt;&gt;& result) {
    // Base case: permutation complete
    if (path.size() == nums.size()) {
        result.push_back(path);
        return;
    }
    
    // Try each unused number
    for (int i = 0; i < nums.size(); i++) {
        if (!used[i]) {
            // Choose
            used[i] = true;
            path.push_back(nums[i]);
            
            // Explore
            generate_permutations(nums, path, used, result);
            
            // Unchoose (backtrack)
            path.pop_back();
            used[i] = false;
        }
    }
}

vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;& nums) {
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    vector&lt;bool&gt; used(nums.size(), false);
    generate_permutations(nums, path, used, result);
    return result;
}</code></pre>

                <h2>Key Optimizations</h2>
                <ul>
                    <li><strong>Pruning:</strong> Skip invalid paths early</li>
                    <li><strong>Memoization:</strong> Cache results of subproblems</li>
                    <li><strong>Constraint propagation:</strong> Use constraints to reduce search space</li>
                </ul>
            </article>
        </section>

        <section id="problems" class="mb-12">
            <div class="max-w-7xl mx-auto">
                <h2 class="section-title text-center">Practice Problems</h2>
                
                <div class="problem-card">
                    <h3 class="text-xl font-semibold mb-3">Problem 1: Permutations (LeetCode #46)</h3>
                    <p class="mb-4">Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre>
                    <button class="toggle-btn" onclick="toggleSolution('sol1')">Show Solution</button>
                    <div id="sol1" class="solution-content">
                        <h4 class="font-semibold mt-4 mb-2">Solution in C++:</h4>
                        <pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class Solution {
public:
    void backtrack(vector&lt;int&gt;& nums, vector&lt;int&gt;& path, 
                   vector&lt;bool&gt;& used, vector&lt;vector&lt;int&gt;&gt;& result) {
        // Base case: permutation complete
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        
        // Try each unused element
        for (int i = 0; i < nums.size(); i++) {
            if (!used[i]) {
                // Choose: add to path and mark as used
                used[i] = true;
                path.push_back(nums[i]);
                
                // Explore: recursively build rest of permutation
                backtrack(nums, path, used, result);
                
                // Unchoose: backtrack
                path.pop_back();
                used[i] = false;
            }
        }
    }
    
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;& nums) {
        vector&lt;vector&lt;int&gt;&gt; result;
        vector&lt;int&gt; path;
        vector&lt;bool&gt; used(nums.size(), false);
        backtrack(nums, path, used, result);
        return result;
    }
};</code></pre>
                        <h4 class="font-semibold mt-4 mb-2">Step-by-Step Simulation (nums = [1, 2]):</h4>
                        <div style="background-color: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1.5rem; margin: 1rem 0; font-family: monospace; font-size: 0.9rem;">
                            <p><strong>Initial:</strong> path = [], used = [false, false]</p>
                            <p style="margin-top: 0.5rem;"><strong>Choose 1:</strong> path = [1], used = [true, false]</p>
                            <p style="margin-left: 2rem;"><strong>Choose 2:</strong> path = [1,2], used = [true, true]</p>
                            <p style="margin-left: 4rem;">Base case! Add [1,2] to result</p>
                            <p style="margin-left: 2rem;"><strong>Backtrack:</strong> Remove 2, path = [1]</p>
                            <p style="margin-left: 2rem;">No more choices, backtrack further</p>
                            <p><strong>Backtrack:</strong> Remove 1, path = []</p>
                            <p style="margin-top: 0.5rem;"><strong>Choose 2:</strong> path = [2], used = [false, true]</p>
                            <p style="margin-left: 2rem;"><strong>Choose 1:</strong> path = [2,1], used = [true, true]</p>
                            <p style="margin-left: 4rem;">Base case! Add [2,1] to result</p>
                            <p style="margin-top: 1rem;"><strong>Result:</strong> [[1,2], [2,1]]</p>
                        </div>
                        <p class="mt-4"><strong>Explanation:</strong> We build permutations by choosing each element as the next element in the permutation. For each choice, we recursively build the rest of the permutation with the remaining elements. After exploring, we backtrack by removing the choice and trying the next option. When no elements remain, we have a complete permutation. The used array tracks which elements are already in the current path to avoid duplicates.</p>
                        <p><strong>Time Complexity:</strong> O(n! × n)</p>
                        <p><strong>Space Complexity:</strong> O(n! × n) for output</p>
                    </div>
                </div>

                <div class="problem-card">
                    <h3 class="text-xl font-semibold mb-3">Problem 2: Subsets (LeetCode #78)</h3>
                    <p class="mb-4">Given an integer array nums of unique elements, return all possible subsets (the power set).</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></pre>
                    <button class="toggle-btn" onclick="toggleSolution('sol2')">Show Solution</button>
                    <div id="sol2" class="solution-content">
                        <h4 class="font-semibold mt-4 mb-2">Solution in C++:</h4>
                        <pre><code>#include &lt;vector&gt;
using namespace std;

class Solution {
public:
    void backtrack(vector&lt;int&gt;& nums, int start, vector&lt;int&gt;& path, 
                   vector&lt;vector&lt;int&gt;&gt;& result) {
        // Add current subset to result
        result.push_back(path);
        
        // Try including each remaining element
        for (int i = start; i < nums.size(); i++) {
            // Choose: include nums[i]
            path.push_back(nums[i]);
            
            // Explore: generate subsets from remaining elements
            backtrack(nums, i + 1, path, result);
            
            // Unchoose: backtrack
            path.pop_back();
        }
    }
    
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;& nums) {
        vector&lt;vector&lt;int&gt;&gt; result;
        vector&lt;int&gt; path;
        backtrack(nums, 0, path, result);
        return result;
    }
};</code></pre>
                        <h4 class="font-semibold mt-4 mb-2">Step-by-Step Simulation (nums = [1, 2]):</h4>
                        <div style="background-color: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1.5rem; margin: 1rem 0; font-family: monospace; font-size: 0.9rem;">
                            <p><strong>Initial:</strong> path = [], start = 0</p>
                            <p>Add [] to result</p>
                            <p style="margin-top: 0.5rem;"><strong>i=0:</strong> Include 1, path = [1]</p>
                            <p style="margin-left: 2rem;">Add [1] to result</p>
                            <p style="margin-left: 2rem;"><strong>i=1:</strong> Include 2, path = [1,2]</p>
                            <p style="margin-left: 4rem;">Add [1,2] to result</p>
                            <p style="margin-left: 2rem;">Backtrack: path = [1]</p>
                            <p>Backtrack: path = []</p>
                            <p style="margin-top: 0.5rem;"><strong>i=1:</strong> Include 2, path = [2]</p>
                            <p style="margin-left: 2rem;">Add [2] to result</p>
                            <p style="margin-top: 1rem;"><strong>Result:</strong> [[], [1], [1,2], [2]]</p>
                        </div>
                        <p class="mt-4"><strong>Explanation:</strong> We generate subsets by either including or excluding each element. At each step, we add the current subset to results, then for each remaining element, we include it and recursively generate subsets from the remaining elements. We use a start index to avoid duplicates and ensure we only consider elements after the current position. This ensures we generate all 2^n subsets exactly once.</p>
                        <p><strong>Time Complexity:</strong> O(2^n × n)</p>
                        <p><strong>Space Complexity:</strong> O(2^n × n)</p>
                    </div>
                </div>

                <div class="problem-card">
                    <h3 class="text-xl font-semibold mb-3">Problem 3: N-Queens (LeetCode #51)</h3>
                    <p class="mb-4">The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>Input: n = 4
Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]</code></pre>
                    <button class="toggle-btn" onclick="toggleSolution('sol3')">Show Solution</button>
                    <div id="sol3" class="solution-content">
                        <h4 class="font-semibold mt-4 mb-2">Solution in C++:</h4>
                        <pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

class Solution {
private:
    vector&lt;vector&lt;string&gt;&gt; result;
    vector&lt;string&gt; board;
    int n;
    
    bool isValid(int row, int col) {
        // Check column above
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') {
                return false;
            }
        }
        
        // Check diagonal \ (top-left)
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') {
                return false;
            }
        }
        
        // Check diagonal / (top-right)
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q') {
                return false;
            }
        }
        
        return true;
    }
    
    void backtrack(int row) {
        // Base case: all queens placed
        if (row == n) {
            result.push_back(board);
            return;
        }
        
        // Try placing queen in each column of current row
        for (int col = 0; col < n; col++) {
            if (isValid(row, col)) {
                // Choose: place queen
                board[row][col] = 'Q';
                
                // Explore: place queens in next row
                backtrack(row + 1);
                
                // Unchoose: backtrack
                board[row][col] = '.';
            }
        }
    }
    
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
        this->n = n;
        board = vector&lt;string&gt;(n, string(n, '.'));
        backtrack(0);
        return result;
    }
};</code></pre>
                        <p class="mt-4"><strong>Explanation:</strong> We place queens row by row. For each row, we try placing a queen in each column. Before placing, we check if it's valid (no conflict with previously placed queens in the same column or diagonals). If valid, we place it and recurse to the next row. If we reach row n, we have a valid solution. We backtrack by removing the queen and trying the next column. The isValid function checks three directions: column above, top-left diagonal, and top-right diagonal.</p>
                        <p><strong>Time Complexity:</strong> O(n!)</p>
                        <p><strong>Space Complexity:</strong> O(n²)</p>
                    </div>
                </div>

                <div class="problem-card">
                    <h3 class="text-xl font-semibold mb-3">Problem 4: Combination Sum (LeetCode #39)</h3>
                    <p class="mb-4">Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]</code></pre>
                    <button class="toggle-btn" onclick="toggleSolution('sol4')">Show Solution</button>
                    <div id="sol4" class="solution-content">
                        <h4 class="font-semibold mt-4 mb-2">Solution in C++:</h4>
                        <pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class Solution {
private:
    void backtrack(vector&lt;int&gt;& candidates, int start, int remaining,
                   vector&lt;int&gt;& path, vector&lt;vector&lt;int&gt;&gt;& result) {
        // Base case: found valid combination
        if (remaining == 0) {
            result.push_back(path);
            return;
        }
        
        // Pruning: remaining is negative
        if (remaining < 0) {
            return;
        }
        
        // Try each candidate starting from 'start'
        for (int i = start; i < candidates.size(); i++) {
            // Choose: add candidate to path
            path.push_back(candidates[i]);
            
            // Explore: try same candidate again (can reuse)
            backtrack(candidates, i, remaining - candidates[i], path, result);
            
            // Unchoose: backtrack
            path.pop_back();
        }
    }
    
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;& candidates, int target) {
        vector&lt;vector&lt;int&gt;&gt; result;
        vector&lt;int&gt; path;
        backtrack(candidates, 0, target, path, result);
        return result;
    }
};</code></pre>
                        <p class="mt-4"><strong>Explanation:</strong> We build combinations by trying each candidate. We can reuse candidates, so we pass the same start index (i) to allow using the same candidate again. We subtract the candidate from the remaining target. If remaining becomes 0, we found a valid combination. If it becomes negative, we prune that path. We backtrack by removing the candidate and trying the next one. This ensures we explore all possible combinations that sum to target.</p>
                        <p><strong>Time Complexity:</strong> O(2^target)</p>
                        <p><strong>Space Complexity:</strong> O(target)</p>
                    </div>
                </div>

                <div class="problem-card">
                    <h3 class="text-xl font-semibold mb-3">Problem 5: Word Search (LeetCode #79)</h3>
                    <p class="mb-4">Given an m x n grid of characters board and a string word, return true if word exists in the grid.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true</code></pre>
                    <button class="toggle-btn" onclick="toggleSolution('sol5')">Show Solution</button>
                    <div id="sol5" class="solution-content">
                        <h4 class="font-semibold mt-4 mb-2">Solution in C++:</h4>
                        <pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

class Solution {
private:
    bool backtrack(vector&lt;vector&lt;char&gt;&gt;& board, const string& word,
                   int row, int col, int index) {
        // Base case: matched all characters
        if (index == word.length()) {
            return true;
        }
        
        // Boundary check
        if (row < 0 || row >= board.size() || 
            col < 0 || col >= board[0].size()) {
            return false;
        }
        
        // Character doesn't match
        if (board[row][col] != word[index]) {
            return false;
        }
        
        // Mark as visited temporarily
        char temp = board[row][col];
        board[row][col] = '#';
        
        // Try all 4 directions
        int directions[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}};
        for (int i = 0; i < 4; i++) {
            int newRow = row + directions[i][0];
            int newCol = col + directions[i][1];
            if (backtrack(board, word, newRow, newCol, index + 1)) {
                return true;
            }
        }
        
        // Backtrack: restore cell value
        board[row][col] = temp;
        return false;
    }
    
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;& board, string word) {
        int m = board.size();
        int n = board[0].size();
        
        // Try starting from each cell
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (backtrack(board, word, i, j, 0)) {
                    return true;
                }
            }
        }
        
        return false;
    }
};</code></pre>
                        <p class="mt-4"><strong>Explanation:</strong> We start from each cell and try to match the word character by character. We mark visited cells temporarily (with '#') to avoid revisiting the same cell in the current path. We explore all 4 directions (up, down, left, right). If we match all characters, we return True. If a path fails, we backtrack by restoring the cell value and trying other paths. This ensures we explore all possible paths without getting stuck in cycles.</p>
                        <p><strong>Time Complexity:</strong> O(m × n × 4^L) where L is word length</p>
                        <p><strong>Space Complexity:</strong> O(L) for recursion stack</p>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="bg-gray-800 text-white mt-12 py-6">
        <div class="container mx-auto text-center">
            <p>&copy; George Meshveliani - CST Department. All rights reserved.</p>
        </div>
    </footer>

    <script>
        function toggleSolution(id) {
            const solution = document.getElementById(id);
            solution.classList.toggle('show');
            const btn = event.target;
            btn.textContent = solution.classList.contains('show') ? 'Hide Solution' : 'Show Solution';
        }
    </script>
</body>
</html>
